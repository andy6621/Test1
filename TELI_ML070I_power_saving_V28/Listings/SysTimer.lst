C51 COMPILER V9.60.0.0   SYSTIMER                                                          12/22/2020 17:53:50 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE SYSTIMER
OBJECT MODULE PLACED IN .\Output\SysTimer.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE SysTimer.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\Include) DEBUG OBJECT
                    -EXTEND PRINT(.\Listings\SysTimer.lst) TABS(2) OBJECT(.\Output\SysTimer.obj)

line level    source

   1          /*****************************************************************************/
   2          /*                                                                                              */
   3          /*  TELI ML070I   MCU                                             */
   4          /*                                                                                              */
   5          /*  SysTimer.c                                                                */
   6          /*                                                                                              */
   7          /*****************************************************************************/
   8          
   9          
  10          #include <math.h>
  11          #include <stdio.h>
  12          
  13          #include "Config.h"
  14          
  15          #include "reg.h"
  16          #include "typedefs.h"
  17          #include "main.h"
  18          #include "i2c.h"
  19          #include "adc.h"
  20          #include "etc_eep.h"
  21          #include "Printf.h"
  22          #include "KeyRemo.h"
  23          #include "Monitor.h"
  24          #include "CPU.h"
  25          #include "HS_DVRProtocol.h"
  26          
  27          
  28          //****************************************************************************
  29          // DEFINITIONS / MACROS
  30          //****************************************************************************
  31          #define GET_EVENT_VALID(x)                      (g_stTimerEvent[x].b1EventValid)
  32          #define SET_EVENT_VALID(x)                      (g_stTimerEvent[x].b1EventValid = _TRUE)
  33          #define CLR_EVENT_VALID(x)                      (g_stTimerEvent[x].b1EventValid = _FALSE)
  34          
  35          #define GET_EVENT_ID(x)                         (g_stTimerEvent[x].b7EventID)
  36          #define SET_EVENT_ID(x, y)                      (g_stTimerEvent[x].b7EventID = y)
  37          
  38          #define GET_EVENT_TIME(x)                       (g_stTimerEvent[x].usTime)
  39          #define SET_EVENT_TIME(x, y)                    (g_stTimerEvent[x].usTime = y)
  40          
  41          
  42          //****************************************************************************
  43          // VARIABLE DECLARATIONS
  44          //****************************************************************************
  45          bit g_bNotifyTimer0Int = _FALSE;
  46          volatile WORD  g_usTimerCounter = 0;
  47          StructTimerEventTableType g_stTimerEvent[_TIMER_EVENT_COUNT];
  48          WORD BatteryBTH=549/*156*//*650*//*880*/,BatteryVoltage=880;
  49          BYTE WDT_Echo_Count=0;
  50          BYTE STAT1_temp=OFF, STAT2_temp=ON,STAT1_Flag=OFF,STAT2_Flag=ON;
  51          
  52          BYTE BattDetect1_COUNT=0, BattDetect2_COUNT=0, BattDetect3_COUNT=0, BattDetect4_COUNT=0,BattDetect5_COUNT=
             -0;
  53          BYTE BattDetectMin_COUNT=0, BattDetectHigh_COUNT=0,BattDetectHighStop_COUNT=0,BattDetectNoStartUp_COUNT=0,
C51 COMPILER V9.60.0.0   SYSTIMER                                                          12/22/2020 17:53:50 PAGE 2   

             -BattDetectStartUp_COUNT=0;
  54          BYTE  BATERY_STAT=0xFF,BATERY_STAT_TEMP=0xFE;
  55          BYTE TEMP_NORMAL_COUNT=0,TEMP_LOW_COUNT=0, TEMP_LOW_WARN_COUNT=0, TEMP_HIGH_COUNT=0,TEMP_HIGH_WARN_COUNT=0
             -;
  56          BYTE TEMP_STAT=0xFF;
  57          BYTE PWM_TEMP=0;  
  58          BYTE CHARGE_TEMP_ABNORMAL=0;
  59          BYTE CHARGE_TEMP_NORMAL=0;
  60          
  61          #if (_DEBUG_MESSAGE_Monitor==ON)
              bit Monitor_flag=OFF;
              #endif
  64          
  65          extern BYTE PowerFlag;
  66          extern BYTE CameraVolt;
  67          extern BYTE PWR_START_flag;
  68          extern StructBatteryInfoType g_stBatteryInfo;
  69          extern BYTE EncorderCountPN;
  70          extern BYTE EncorderLenint;
  71          extern short EncorderCount;
  72          extern WORD EncorderLenfloaat;
  73          extern StructPowerInfoType idata g_stPowerInfo;
  74          extern BYTE day,hour,minute,second;
  75          extern StructDVRInfoType g_stDVRInfo;
  76          extern BYTE Power_down_mode;
  77          
  78          
  79          //--------------------------------------------------
  80          // Definitions of Timer2
  81          //--------------------------------------------------
  82          #define _EVENT_TIME_MAX                         61000 // Please do not modify this value.
  83          
  84          //****************************************************************************
  85          // CODE TABLES
  86          //****************************************************************************
  87          
  88          
  89          //****************************************************************************
  90          // FUNCTION DECLARATIONS
  91          //****************************************************************************
  92          void SysTimerHandler(void);
  93          void SysTimerEventProc(EnumSystemTimerEventID enumEventID);
  94          void MCUTimerInitialTimerEvent(void);
  95          void MCUTimerActiveTimerEvent(WORD usTime, BYTE ucEventID);
  96          void MCUTimerCancelTimerEvent(BYTE ucEventID);
  97          void MCUTimerDelayXms(WORD usNum);
  98          extern WORD GetBatteryBTH(void);
  99          extern WORD GetBatteryVoltage(void);
 100          extern void SetAD5110Step(BYTE newv) ;
 101          extern void UserInterfacePowerSwitch(EnumPowerAction enumSwitch);
 102          extern void SysPowerSwitch(EnumPowerAction enumSwitch);
 103          extern void UserInterfaceBatteryChargeMode(EnumBatteryStatus enumSwitch);
 104          extern void SET_MCU_POWER_DOWN_MODE(void);
 105          
 106          
 107          //****************************************************************************
 108          // FUNCTION DEFINITIONS
 109          //****************************************************************************
 110          //--------------------------------------------------
 111          // Description  : Timer Delay
 112          // Input Value  : usNum --> Delay in ms
 113          // Output Value : None
C51 COMPILER V9.60.0.0   SYSTIMER                                                          12/22/2020 17:53:50 PAGE 3   

 114          //--------------------------------------------------
 115          void MCUTimerDelayXms(WORD usNum)
 116          {
 117   1          if(usNum)
 118   1          {
 119   2              g_bNotifyTimer0Int = _FALSE;
 120   2      
 121   2              while(_TRUE)
 122   2              {
 123   3                  if(g_bNotifyTimer0Int)
 124   3                  {
 125   4                      g_bNotifyTimer0Int = _FALSE;
 126   4      
 127   4                      if(--usNum)
 128   4                      {
 129   5                      }
 130   4                      else
 131   4                      {
 132   5                          return;
 133   5                      }
 134   4                  }
 135   3              }
 136   2          }
 137   1      }
 138          
 139          //--------------------------------------------------
 140          // Description  : Get Event Time
 141          // Input Value  : ucEventIndex --> Event which time is needed
 142          // Output Value : Event Time
 143          //--------------------------------------------------
 144          WORD MCUTimerGetEventTime(BYTE ucEventIndex)
 145          {
 146   1          return GET_EVENT_TIME(ucEventIndex);
 147   1      }
 148          
 149          //--------------------------------------------------
 150          // Description  : Get Event ID
 151          // Input Value  : Referenced Event Index
 152          // Output Value : Stored Event ID
 153          //--------------------------------------------------
 154          BYTE MCUTimerGetEventID(BYTE ucEventIndex)
 155          {
 156   1          return GET_EVENT_ID(ucEventIndex);
 157   1      }
 158          
 159          //--------------------------------------------------
 160          // Description  : Clear Event Time
 161          // Input Value  : ucEventIndex --> Event which time is needed to be cleared
 162          // Output Value : None
 163          //--------------------------------------------------
 164          
 165          void MCUTimerClrEventValid(BYTE ucEventIndex)
 166          {
 167   1          CLR_EVENT_VALID(ucEventIndex);
 168   1      }
 169          
 170          //--------------------------------------------------
 171          // Description  : Check if Event is Valid
 172          // Input Value  : ucEventIndex --> Event to be checked
 173          // Output Value : Validity(_TRUE/_FALSE)
 174          //--------------------------------------------------
 175          bit MCUTimerCheckEventValid(BYTE ucEventIndex)
C51 COMPILER V9.60.0.0   SYSTIMER                                                          12/22/2020 17:53:50 PAGE 4   

 176          {
 177   1          return GET_EVENT_VALID(ucEventIndex);;
 178   1      }
 179          
 180          //--------------------------------------------------
 181          // Description  : Get Timer Counter.
 182          // Input Value  : None
 183          // Output Value : Timer Counter
 184          //--------------------------------------------------
 185          WORD MCUTimerGetTimerCounter(void)
 186          {
 187   1          WORD usPresentTime = g_usTimerCounter;
 188   1         
 189   1          // When get counter,timer interrupt maybe change counter.
 190   1          // Get twice to avoid it.
 191   1          if(abs(g_usTimerCounter - usPresentTime) > 0x7F)
 192   1          {
 193   2              usPresentTime = g_usTimerCounter;
 194   2          } 
 195   1      
 196   1          return usPresentTime;
 197   1      }
 198          //--------------------------------------------------
 199          // Description  : Check timer and events. We have to run this function when setting up a timer for an even
             -t.
 200          // Input Value  : usTime    --> Unit in 1ms, range in 0.001 ~ 61sec
 201          // Output Value : Return usPresentTime
 202          //--------------------------------------------------
 203          WORD MCUTimerCheckTimerEvent(WORD usTime)
 204          {
 205   1          BYTE ucTimerEventCnt = 0;
 206   1          WORD usPresentTime = 0;
 207   1      
 208   1          usPresentTime = MCUTimerGetTimerCounter();
 209   1          
 210   1          if(usTime > _EVENT_TIME_MAX) 
 211   1          {
 212   2              usTime = _EVENT_TIME_MAX;
 213   2          }
 214   1         
 215   1          if(((usPresentTime + usTime) > _EVENT_TIME_MAX) || // Size Limit of Timer Counter             
 216   1             ((usPresentTime + usTime) < usPresentTime)) // Timer Counter Overflow
 217   1          { 
 218   2              g_usTimerCounter = 0;
 219   2          
 220   2              // Reset Timer Event Counter
 221   2              for(ucTimerEventCnt = 0; ucTimerEventCnt < _TIMER_EVENT_COUNT; ucTimerEventCnt++)
 222   2              {
 223   3                  if(GET_EVENT_VALID(ucTimerEventCnt) == _TRUE)
 224   3                  {
 225   4                      if(GET_EVENT_TIME(ucTimerEventCnt) > usPresentTime)
 226   4                      {
 227   5                          SET_EVENT_TIME(ucTimerEventCnt, (GET_EVENT_TIME(ucTimerEventCnt) - usPresentTime));
 228   5                      }
 229   4                      else
 230   4                      {
 231   5                          SET_EVENT_TIME(ucTimerEventCnt, 0);
 232   5                      }
 233   4                  }
 234   3              }
 235   2              
 236   2              usPresentTime = 0;
C51 COMPILER V9.60.0.0   SYSTIMER                                                          12/22/2020 17:53:50 PAGE 5   

 237   2          }    
 238   1      
 239   1          return usPresentTime;
 240   1      }
 241          
 242          //--------------------------------------------------
 243          // Description  : Initial timer and events. We have to run this function at firmware startup
 244          // Input Value  : None
 245          // Output Value : None
 246          //--------------------------------------------------
 247          void MCUTimerInitialTimerEvent(void)
 248          {
 249   1          BYTE ucTimerEventCnt = 0;
 250   1      
 251   1          for(ucTimerEventCnt = 0; ucTimerEventCnt < _TIMER_EVENT_COUNT; ucTimerEventCnt++)
 252   1          {
 253   2              CLR_EVENT_VALID(ucTimerEventCnt);
 254   2          }
 255   1      
 256   1         // TR2 = 1;
 257   1      }
 258          
 259          //--------------------------------------------------
 260          // Description  : Active Timer Event
 261          // Input Value  : usTime --> Time to active Timer Event
 262          //          ucEventID --> Event to be actived
 263          // Output Value : None
 264          //--------------------------------------------------
 265          void MCUTimerActiveTimerEvent(WORD usTime, BYTE ucEventID)
 266          {
 267   1          BYTE ucEventIndex = 0;
 268   1      
 269   1          // Search for Existing Event with the same Event ID
 270   1          for(ucEventIndex = 0; ucEventIndex < _TIMER_EVENT_COUNT; ucEventIndex++)
 271   1          {
 272   2              if(GET_EVENT_VALID(ucEventIndex) == _TRUE)
 273   2              {
 274   3                  if(GET_EVENT_ID(ucEventIndex) == ucEventID)
 275   3                  {
 276   4                      return;
 277   4                  }
 278   3              }
 279   2          }
 280   1      
 281   1          // Choose any Vacant Storage for Event
 282   1          for(ucEventIndex = 0; ucEventIndex < _TIMER_EVENT_COUNT; ucEventIndex++)
 283   1          {
 284   2              if(GET_EVENT_VALID(ucEventIndex) == _FALSE)
 285   2              {
 286   3                  SET_EVENT_VALID(ucEventIndex);
 287   3                  SET_EVENT_ID(ucEventIndex, ucEventID);
 288   3                  SET_EVENT_TIME(ucEventIndex, (WORD)((DWORD)(MCUTimerCheckTimerEvent(usTime)) + usTime));
 289   3                  return;
 290   3              }
 291   2          }
 292   1      
 293   1          //Printf("No More Available Storage for Simultaneous Event!!!!!!");
 294   1      }
 295          
 296          //--------------------------------------------------
 297          // Description  : Cancel an event
 298          // Input Value  : Event     --> Event which we want to cancel
C51 COMPILER V9.60.0.0   SYSTIMER                                                          12/22/2020 17:53:50 PAGE 6   

 299          // Output Value : None
 300          //--------------------------------------------------
 301          void MCUTimerCancelTimerEvent(BYTE ucEventID)
 302          {
 303   1          BYTE ucEventIndex = 0;
 304   1          
 305   1          // Search for Existing Event with the same Event ID
 306   1          for(ucEventIndex = 0; ucEventIndex < _TIMER_EVENT_COUNT; ucEventIndex++)
 307   1          {
 308   2              if(GET_EVENT_VALID(ucEventIndex) == _TRUE)
 309   2              {
 310   3                  if(GET_EVENT_ID(ucEventIndex) == ucEventID)
 311   3                  {
 312   4                      CLR_EVENT_VALID(ucEventIndex);
 313   4                      return;
 314   4                  }
 315   3              }
 316   2          }      
 317   1      }
 318          
 319          //--------------------------------------------------
 320          // Description  : Reactive a timer for an event. If the event is exist,
 321          //                this function will reset the executing time and restart.
 322          // Input Value  : usTime    --> Unit in 1ms, range in 0.01 ~ 61 sec
 323          //                Event     --> Execute Event while timeup
 324          // Output Value : None
 325          //--------------------------------------------------
 326          void MCUTimerReactiveTimerEvent(WORD usTime, BYTE ucEventID)
 327          {
 328   1          BYTE ucEventIndex = 0;
 329   1      
 330   1          // Search for Existing Event with the same Event ID
 331   1          for(ucEventIndex = 0; ucEventIndex < _TIMER_EVENT_COUNT; ucEventIndex++)
 332   1          {
 333   2              if(GET_EVENT_VALID(ucEventIndex) == _TRUE)
 334   2              {
 335   3                  if(GET_EVENT_ID(ucEventIndex) == ucEventID)
 336   3                  {
 337   4                      SET_EVENT_TIME(ucEventIndex, (WORD)((DWORD)(MCUTimerCheckTimerEvent(usTime)) + usTime));
 338   4                      return;
 339   4                  }
 340   3              }
 341   2          }    
 342   1      
 343   1          // Choose any Vacant Storage for Event
 344   1          for(ucEventIndex = 0; ucEventIndex < _TIMER_EVENT_COUNT; ucEventIndex++)
 345   1          {
 346   2              if(GET_EVENT_VALID(ucEventIndex) == _FALSE)
 347   2              {
 348   3                  SET_EVENT_VALID(ucEventIndex);
 349   3                  SET_EVENT_ID(ucEventIndex, ucEventID);
 350   3                  SET_EVENT_TIME(ucEventIndex, (WORD)((DWORD)(MCUTimerCheckTimerEvent(usTime)) + usTime));
 351   3                  return;
 352   3              }
 353   2          }   
 354   1      }
 355          
 356          
 357          void UserInterfaceTimerEventProc(BYTE ucEventID)
 358          {
 359   1      
 360   1      switch(ucEventID)
C51 COMPILER V9.60.0.0   SYSTIMER                                                          12/22/2020 17:53:50 PAGE 7   

 361   1      {
 362   2      
 363   2        case _USER_TIMER_EVENT_OSD_CAMERA_VOLTAGE_INC:
 364   2            SetAD5110Step(CameraVolt);
 365   2            WriteEEP(EEP_CameraVolt, CameraVolt);  
 366   2            #if(_DEBUG_MESSAGE_UserInterfaceTimerEvent==ON)
                    GraphicsPrint(YELLOW,"(CAM_INC %d)",(WORD)(CameraVolt));  
                    #endif
 369   2              break;
 370   2      
 371   2        case _USER_TIMER_EVENT_OSD_CAMERA_VOLTAGE_DEC:
 372   2            SetAD5110Step(CameraVolt);  
 373   2            WriteEEP(EEP_CameraVolt, CameraVolt);  
 374   2            #if(_DEBUG_MESSAGE_UserInterfaceTimerEvent==ON)
                    GraphicsPrint(YELLOW,"(CAM_DEC %d)",(WORD)(CameraVolt));  
                    #endif
 377   2            break;
 378   2              case _USER_TIMER_EVENT_OSD_SET_CAMERA_VOLTAGE:
 379   2            SetAD5110Step(CameraVolt);  
 380   2            WriteEEP(EEP_CameraVolt, CameraVolt);     
 381   2            #if(_DEBUG_MESSAGE_UserInterfaceTimerEvent==ON)
                    GraphicsPrint(MAGENTA,"(CAM_VOLT_LEVEL=%d)",(WORD)(CameraVolt));  
                    #endif
 384   2            break;
 385   2              case _USER_TIMER_EVENT_OSD_GET_MCU_VERSION:
 386   2            MCU_SendCmdToDVR(MCU_PROTOCOL_CMD_REPLY_MCU_FW);  
 387   2            #if(_DEBUG_MESSAGE_UserInterfaceTimerEvent==ON)
                    GraphicsPrint(YELLOW,"(GET_MCU_VERSION)");  
                    #endif
 390   2            break;
 391   2      
 392   2        case _USER_TIMER_EVENT_OSD_DVR_FACTORY_MODE:
 393   2      
 394   2              if(GET_AC_PLUG()==_TRUE)
 395   2              {
 396   3              MCU_SendCmdToDVR(MCU_PROTOCOL_CMD_ENTRY_FACTORY);     
 397   3              #if(_DEBUG_MESSAGE_UserInterfaceTimerEvent==ON)
                      GraphicsPrint(RED,"(DVR_FACTORY_MODE)");  
                      #endif
 400   3              }
 401   2            #if(_DEBUG_MESSAGE_UserInterfaceTimerEvent==ON)
                    else
                      {
                      GraphicsPrint(RED,"(DVR_FACTORY_FAIL)");      
                      }
                    #endif
 407   2            
 408   2            break;
 409   2      
 410   2             case _USER_TIMER_EVENT_OSD_MCU_ENTRY_SLEEP_MODE:
 411   2          
 412   2              if(GET_DVR_EntrySleepMode()==_FALSE)
 413   2              {
 414   3              SET_TARGET_POWER_STATUS(_POWER_STATUS_SAVING);
 415   3              SET_DVR_EntrySleepMode();
 416   3              #if(_DEBUG_MESSAGE_UserInterfaceTimerEvent==ON)
                        GraphicsPrint(YELLOW,"(MCU_NORMAL_TO_SLEEP_MODE)");    
                      #endif        
 419   3              }
 420   2              break;
 421   2      
 422   2        case _USER_TIMER_EVENT_OSD_DISTANCE_RESET:
C51 COMPILER V9.60.0.0   SYSTIMER                                                          12/22/2020 17:53:50 PAGE 8   

 423   2          EncorderCount=0;
 424   2          EncorderLenint=0;
 425   2          EncorderLenfloaat=0;
 426   2          EncorderCountPN=0;
 427   2          #if(_DEBUG_MESSAGE_UserInterfaceTimerEvent==ON)
                  GraphicsPrint(YELLOW,"\r\n ClearEncorder ",0);
                  #endif
 430   2             //Printf("(DISTANCE_RESET)");   
 431   2             break;
 432   2      
 433   2         case _USER_TIMER_EVENT_OSD_DVR_REBOOT:
 434   2            #if(_DEBUG_MESSAGE_UserInterfaceTimerEvent==ON)
                     GraphicsPrint(YELLOW,"(DVR_REBOOT)");  
                     #endif
 437   2              if(GET_DVR_Reboot()==_TRUE) 
 438   2                {
 439   3                CLR_DVR_Reboot();
 440   3                CLR_DVR_SystemReadyNotic();
 441   3                 UserInterfaceBatteryChargeMode(_BATT_STATUS_DVR_OFF);
 442   3                MCUTimerActiveTimerEvent(SEC(3), _USER_TIMER_EVENT_OSD_DVR_REBOOT);
 443   3                }
 444   2              else
 445   2              {
 446   3                 UserInterfaceBatteryChargeMode(_BATT_STATUS_DVR_ON);
 447   3              }
 448   2              break;
 449   2      
 450   2         case _USER_TIMER_EVENT_OSD_DVR_SHUTDOWN:
 451   2            #if(_DEBUG_MESSAGE_UserInterfaceTimerEvent==ON)
                     GraphicsPrint(YELLOW,"(DVR_SHUTDOWN)");  
                    #endif
 454   2            SET_DVR_Shutdown();
 455   2            MCU_SendCmdToDVR(MCU_PROTOCOL_CMD_SYSTEM_SHUTDOWN);
 456   2             MCUTimerActiveTimerEvent(SEC(15), _USER_TIMER_EVENT_OSD_DVR_SHUTDOWN);
 457   2             break;
 458   2      
 459   2            case  _USER_TIMER_EVENT_OSD_DVR_ENTER_ISP_MODE:
 460   2          #if(_DEBUG_MESSAGE_UserInterfaceTimerEvent==ON)
                     GraphicsPrint(YELLOW,"(MCU_ENTER_ISP_MODE)");      
                  #endif
 463   2              enter_isp();
 464   2             break;
 465   2      
 466   2        case _USER_TIMER_EVENT_OSD_ENCODER_DEVIATION_SETTING:     
 467   2            #if(_DEBUG_MESSAGE_UserInterfaceTimerEvent==ON)
                    GraphicsPrint(YELLOW,"(ENCODER_SET)");  
                    #endif
 470   2            break;
 471   2      
 472   2        case _USER_TIMER_EVENT_PANEL_BACKLIGHT_ON:
 473   2          SET_PWCTRL();
 474   2          #if(_DEBUG_MESSAGE_UserInterfaceTimerEvent==ON)
                  GraphicsPrint(YELLOW,"(Panel_ON)"); 
                  #endif
 477   2             UserInterfacePowerSwitch(_POWER_ACTION_PANEL_POWER_ON);    
 478   2          break;
 479   2      
 480   2        case _USER_TIMER_EVENT_OSD_DVR_STOP_REBOOT:
 481   2          #if(_DEBUG_MESSAGE_UserInterfaceTimerEvent==ON)
                  GraphicsPrint(YELLOW,"(DVR STOP REBOOT)");  
                  #endif
 484   2          break;
C51 COMPILER V9.60.0.0   SYSTIMER                                                          12/22/2020 17:53:50 PAGE 9   

 485   2      
 486   2        #if (_DEBUG_MESSAGE_Monitor==ON)
                case _USER_TIMER_EVENT_Monitor_ON:
                 Monitor_flag=_FALSE;
                  break;
                #endif
 491   2      
 492   2         default:   break;
 493   2         
 494   2      
 495   2      }
 496   1        
 497   1      }
 498          
 499          //--------------------------------------------------
 500          // Description  : Timer Handler
 501          // Input Value  : None
 502          // Output Value : None
 503          //--------------------------------------------------
 504          void SysTimerHandler(void)
 505          {
 506   1          BYTE ucTimerEventIndex = 0;
 507   1          BYTE ucTimerEventID = 0;    
 508   1          WORD usPresentTime = 0;
 509   1      
 510   1          for(ucTimerEventIndex = 0; ucTimerEventIndex < _TIMER_EVENT_COUNT; ucTimerEventIndex++)
 511   1          {
 512   2              usPresentTime = MCUTimerGetTimerCounter();
 513   2      
 514   2              if(MCUTimerCheckEventValid(ucTimerEventIndex) == _FALSE)
 515   2              {
 516   3                  continue;
 517   3              }         
 518   2              
 519   2              if(usPresentTime > MCUTimerGetEventTime(ucTimerEventIndex))
 520   2              {
 521   3                  MCUTimerClrEventValid(ucTimerEventIndex);
 522   3      
 523   3                  // Get Event ID From Event Index
 524   3                  ucTimerEventID = MCUTimerGetEventID(ucTimerEventIndex);
 525   3                  
 526   3                  if(ucTimerEventID < _USER_TIMER_EVENT_END)
 527   3                  {
 528   4                      UserInterfaceTimerEventProc(ucTimerEventID);
 529   4                      
 530   4                      continue;
 531   4                  }
 532   3      
 533   3                  if(ucTimerEventID < _SYSTEM_TIMER_EVENT_END)
 534   3                  {
 535   4                      SysTimerEventProc(ucTimerEventID);
 536   4                      
 537   4                      continue;
 538   4                  }
 539   3                  
 540   3               //   MCUTimerEventProc(ucTimerEventID);
 541   3              }
 542   2          }
 543   1      
 544   1      }
 545          
 546          //--------------------------------------------------
C51 COMPILER V9.60.0.0   SYSTIMER                                                          12/22/2020 17:53:50 PAGE 10  

 547          // Description  : Timer Event Process
 548          // Input Value  : enumEventID --> Event to be processed
 549          // Output Value : None
 550          //--------------------------------------------------
 551          void SysTimerEventProc(EnumSystemTimerEventID enumEventID)
 552          {
 553   1      
 554   1      switch(enumEventID)
 555   1         { 
 556   2         case _SYSTEM_TIMER_EVENT_GRN_RED_OFF:
 557   2           PowerLED(_SYSTEM_TIMER_EVENT_GRN_RED_OFF);
 558   2        break;
 559   2      
 560   2         case _SYSTEM_TIMER_EVENT_GRN_ON_RED_OFF:
 561   2         PowerLED(_SYSTEM_TIMER_EVENT_GRN_ON_RED_OFF);
 562   2        break;
 563   2      
 564   2         case _SYSTEM_TIMER_EVENT_GRN_OFF_RED_ON: 
 565   2          PowerLED(_SYSTEM_TIMER_EVENT_GRN_OFF_RED_ON);
 566   2        break;
 567   2      
 568   2         case _SYSTEM_TIMER_EVENT_GRN_RED_ON:
 569   2            PowerLED(_SYSTEM_TIMER_EVENT_GRN_RED_ON);
 570   2          break;
 571   2      
 572   2         case _SYSTEM_TIMER_EVENT_GRN_BLINK:
 573   2           PowerLED(_SYSTEM_TIMER_EVENT_GRN_BLINK);
 574   2           MCUTimerActiveTimerEvent(SEC(0.25), _SYSTEM_TIMER_EVENT_GRN_BLINK);
 575   2          break;
 576   2      
 577   2         case _SYSTEM_TIMER_EVENT_GRN_2S_BLINK:
 578   2           PowerLED(_SYSTEM_TIMER_EVENT_GRN_BLINK);
 579   2           MCUTimerActiveTimerEvent(SEC(1), _SYSTEM_TIMER_EVENT_GRN_2S_BLINK);
 580   2          break;
 581   2      
 582   2         case _SYSTEM_TIMER_EVENT_RED_BLINK:
 583   2           PowerLED(_SYSTEM_TIMER_EVENT_RED_BLINK);
 584   2           MCUTimerActiveTimerEvent(SEC(1), _SYSTEM_TIMER_EVENT_RED_BLINK);
 585   2      
 586   2          break;  
 587   2      
 588   2        case _SYSTEM_TIMER_EVENT_GRN_RED_BLINK:
 589   2           PowerLED(_SYSTEM_TIMER_EVENT_GRN_RED_BLINK);
 590   2           MCUTimerActiveTimerEvent(SEC(1), _SYSTEM_TIMER_EVENT_GRN_RED_BLINK);
 591   2      
 592   2         break; 
 593   2      
 594   2         case _SYSTEM_TIMER_EVENT_GRN_ON_RED_BLINK:
 595   2          PowerLED(_SYSTEM_TIMER_EVENT_GRN_ON_RED_BLINK);
 596   2          MCUTimerActiveTimerEvent(SEC(1), _SYSTEM_TIMER_EVENT_GRN_ON_RED_BLINK);
 597   2          break; 
 598   2          break;
 599   2      
 600   2         case _SYSTEM_TIMER_EVENT_GRN_2S_BLINK_RED_ON:
 601   2           PowerLED(_SYSTEM_TIMER_EVENT_GRN_2S_BLINK_RED_ON);
 602   2           MCUTimerActiveTimerEvent(SEC(1), _SYSTEM_TIMER_EVENT_GRN_2S_BLINK_RED_ON);
 603   2              break;
 604   2       case _SYSTEM_TIMER_EVENT_BATT_LOW_RED_BLINK:
 605   2        PowerLED(_SYSTEM_TIMER_EVENT_GRN_RED_OFF);
 606   2        PowerLED(_SYSTEM_TIMER_EVENT_GRN_OFF_RED_ON);
 607   2        MCUTimerDelayXms(500);
 608   2        PowerLED(_SYSTEM_TIMER_EVENT_GRN_RED_OFF);
C51 COMPILER V9.60.0.0   SYSTIMER                                                          12/22/2020 17:53:50 PAGE 11  

 609   2        MCUTimerDelayXms(500);
 610   2      
 611   2        PowerLED(_SYSTEM_TIMER_EVENT_GRN_OFF_RED_ON);
 612   2        MCUTimerDelayXms(500);
 613   2        PowerLED(_SYSTEM_TIMER_EVENT_GRN_RED_OFF);
 614   2        MCUTimerDelayXms(500);
 615   2      
 616   2        PowerLED(_SYSTEM_TIMER_EVENT_GRN_OFF_RED_ON);
 617   2        MCUTimerDelayXms(500);
 618   2        PowerLED(_SYSTEM_TIMER_EVENT_GRN_RED_OFF);
 619   2        MCUTimerDelayXms(500);
 620   2      
 621   2        SET_BATTERY_CHARGE_STATE(_BATT_STATUS_NONE);//reset battery state.
 622   2        break;
 623   2        
 624   2         case _SYSTEM_TIMER_EVENT_JUDGE_CHECK_AC_CABLE:
 625   2        
 626   2          if(Check_ADAP_IN()==_TRUE)    
 627   2          {
 628   3            
 629   3                  if(GET_AC_PLUG()==_FALSE)
 630   3                  { 
 631   4          
 632   4                  if(MCUTimerCheckEventValid(_SYSTEM_TIMER_EVENT_JUDGE_BATT_MODE)==_TRUE)
 633   4                    {
 634   5                      #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
                              GraphicsPrint(BLUE,"(AC1)");
                              #endif  
 637   5      
 638   5                    MCUTimerCancelTimerEvent( _SYSTEM_TIMER_EVENT_JUDGE_BATT_MODE);  
 639   5                    MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_JUDGE_BATT_MODE); 
 640   5                    }
 641   4          
 642   4                  if(MCUTimerCheckEventValid(_SYSTEM_TIMER_EVENT_JUDGE_AC_MODE)==_TRUE)
 643   4                    {
 644   5                    MCUTimerCancelTimerEvent( _SYSTEM_TIMER_EVENT_JUDGE_AC_MODE);  
 645   5                    MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_JUDGE_AC_MODE); 
 646   5                    #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
                            GraphicsPrint(BLUE,"(AC2)");
                            #endif  
 649   5                    }
 650   4          
 651   4                  }
 652   3            
 653   3          }
 654   2          else
 655   2            {
 656   3              if(GET_AC_PLUG()==_TRUE)
 657   3              {
 658   4                    if(MCUTimerCheckEventValid(_SYSTEM_TIMER_EVENT_JUDGE_BATT_MODE)==_TRUE)
 659   4                    {
 660   5                    MCUTimerCancelTimerEvent( _SYSTEM_TIMER_EVENT_JUDGE_BATT_MODE);  
 661   5                    MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_JUDGE_BATT_MODE); 
 662   5                    #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
                            GraphicsPrint(BLUE,"(AC3)");
                            #endif
 665   5                    }
 666   4          
 667   4                  if(MCUTimerCheckEventValid(_SYSTEM_TIMER_EVENT_JUDGE_AC_MODE)==_TRUE)
 668   4                    {
 669   5                    #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
                            GraphicsPrint(BLUE,"(AC4)");
C51 COMPILER V9.60.0.0   SYSTIMER                                                          12/22/2020 17:53:50 PAGE 12  

                            #endif  
 672   5                    MCUTimerCancelTimerEvent( _SYSTEM_TIMER_EVENT_JUDGE_AC_MODE);  
 673   5                    MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_JUDGE_AC_MODE); 
 674   5                    }
 675   4              }
 676   3            }
 677   2                
 678   2            MCUTimerActiveTimerEvent(SEC(1), _SYSTEM_TIMER_EVENT_JUDGE_CHECK_AC_CABLE);   
 679   2            break;
 680   2       case _SYSTEM_TIMER_EVENT_REPLAY_REGULAR_DATA:
 681   2      
 682   2          if(GET_DVR_SystemReadyNotic()==_TRUE)          
 683   2           MCU_SendCmdToDVR(MCU_PROTOCOL_CMD_REGULAR_DATA);
 684   2          
 685   2           MCUTimerActiveTimerEvent(SEC(1), _SYSTEM_TIMER_EVENT_REPLAY_REGULAR_DATA);
 686   2           
 687   2        break;
 688   2        case _SYSTEM_TIMER_EVENT_POWER_OFF_ON_DELAY:
 689   2              #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
                      GraphicsPrint(RED,"(CLR_DVR_PowerOFFDelay)");
                      #endif
 692   2            CLR_DVR_PowerOFFDelay();
 693   2          break;
 694   2          case _SYSTEM_TIMER_EVENT_JUDGE_FIRST_GET_BATT_BTH_STATE:
 695   2            #if (_DEBUG_MESSAGE_BATTERY_TEST)
                    #else
 697   2            BatteryVoltage=GetBatteryVoltage();
 698   2      //      BatteryBTH=GetBatteryBTH()+7;
 699   2            BatteryBTH=GetBatteryBTH();
 700   2            #endif
 701   2      
 702   2            if(BatteryVoltage<=BATTERY_CAPACITY_MIN) //<11.6V
 703   2              BATERY_STAT=_BATT_STATUS_CAPACITY_MIN;
 704   2              else if((BatteryVoltage>BATTERY_CAPACITY_MIN)&&(BatteryVoltage<=BATTERY_CAPACITY_NO_STARTUP))
 705   2                BATERY_STAT=_BATT_STATUS_CAPACITY_NO_STARTUP;       
 706   2              else if((BatteryVoltage>BATTERY_CAPACITY_NO_STARTUP)&&(BatteryVoltage<=BATTERY_CAPACITY_LEVEL0))
 707   2                BATERY_STAT=_BATT_STATUS_CAPACITY_LEVEL0;
 708   2              else if((BatteryVoltage>BATTERY_CAPACITY_LEVEL0)&&(BatteryVoltage<=BATTERY_CAPACITY_LEVEL1))
 709   2                BATERY_STAT=_BATT_STATUS_CAPACITY_LEVEL1;
 710   2              else if((BatteryVoltage>BATTERY_CAPACITY_LEVEL1)&&(BatteryVoltage<=BATTERY_CAPACITY_LEVEL2))
 711   2                BATERY_STAT=_BATT_STATUS_CAPACITY_LEVEL2;
 712   2              else if((BatteryVoltage>BATTERY_CAPACITY_LEVEL2)&&(BatteryVoltage<=BATTERY_CAPACITY_LEVEL3))
 713   2                BATERY_STAT=_BATT_STATUS_CAPACITY_LEVEL3;
 714   2              else if((BatteryVoltage>BATTERY_CAPACITY_LEVEL3)&&(BatteryVoltage<=BATTERY_CAPACITY_HIGH))
 715   2                BATERY_STAT=_BATT_STATUS_CAPACITY_LEVEL4;
 716   2              else if((BatteryVoltage>BATTERY_CAPACITY_HIGH)&&(BatteryVoltage<=BATTERY_CAPACITY_HIGH_STOP)&&(PowerFl
             -ag==ON))
 717   2                BATERY_STAT=_BATT_STATUS_CAPACITY_MAX;
 718   2              else if((BatteryVoltage>BATTERY_CAPACITY_HIGH)&&(BatteryVoltage<=(BATTERY_CAPACITY_HIGH_STOP+9))&&(Pow
             -erFlag==OFF))
 719   2                BATERY_STAT=_BATT_STATUS_CAPACITY_MAX;
 720   2              else          
 721   2                BATERY_STAT=_BATT_STATUS_CAPACITY_MAX_STOP;
 722   2      
 723   2            SET_BATTERY_STATE(BATERY_STAT);
 724   2          
 725   2            SET_BATTERY_CAPACITY(BatteryVoltage);
 726   2      
 727   2      
 728   2            if((BatteryBTH<=BTH_TEMP_HIGH)&&(BatteryBTH>BTH_TEMP_MIN)) //High temperature.
 729   2              TEMP_STAT=_BATT_STATUS_TEMP_HIGH;
 730   2              else if((BatteryBTH>BTH_TEMP_HIGH)&&(BatteryBTH<=BTH_TEMP_HIGH_WARN))//50~55 warnning
C51 COMPILER V9.60.0.0   SYSTIMER                                                          12/22/2020 17:53:50 PAGE 13  

 731   2                TEMP_STAT=_BATT_STATUS_TEMP_HIGH_WARN;
 732   2              else if((BatteryBTH>BTH_TEMP_HIGH_WARN)&&(BatteryBTH<=BTH_TEMP_LOW_WARN))
 733   2                TEMP_STAT=_BATT_STATUS_TEMP_NORMAL;
 734   2              else if((BatteryBTH>BTH_TEMP_LOW_WARN)&&(BatteryBTH<=BTH_TEMP_LOW))  //0~-5 warnning
 735   2                TEMP_STAT=_BATT_STATUS_TEMP_LOW_WARN;
 736   2              else if((BatteryBTH>BTH_TEMP_LOW)&&(BatteryBTH<=BATTERY_ACD_no_battery)) /// if(BatteryBTH>BTH_TEMP_LO
             -W)  //-5~-10 warnning
 737   2                TEMP_STAT=_BATT_STATUS_TEMP_LOW;
 738   2              else{
 739   3                SET_NO_BATTERY();
 740   3                SET_BATTERY_STATE(_BATT_STATUS_NO_BATT);
 741   3                TEMP_STAT=_BATT_STATUS_TEMP_NORMAL; ///no DC12V input
 742   3                }
 743   2      
 744   2              if(GET_BATTERY_CHARGE_STATE()==_BATT_STATUS_NO_BATT)  
 745   2              TEMP_STAT=_BATT_STATUS_TEMP_NORMAL;
 746   2      
 747   2              SET_BTH_STATE(TEMP_STAT); 
 748   2      
 749   2              STAT1_temp=GET_STAT1(); 
 750   2              if(STAT1_Flag!=STAT1_temp)
 751   2              STAT1_Flag=STAT1_temp;
 752   2                    
 753   2              STAT2_temp=GET_STAT2(); 
 754   2              if(STAT2_Flag!=STAT2_temp)
 755   2              STAT2_Flag=STAT2_temp;        
 756   2      
 757   2            /*
 758   2            if((BatteryBTH<=CHARGE_TEMP_HIGH)&&(BatteryBTH>CHARGE_TEMP_LOW))  
 759   2              {
 760   2              if(GET_AC_PLUG()==_TRUE)  
 761   2                SET_CHARGE_TMEP_ABNORMAL();
 762   2      
 763   2              if(GET_BATTERY_CHARGE_STATE()==_BATT_STATUS_NO_BATT)  
 764   2                    CLR_CHARGE_TMEP_ABNORMAL();
 765   2              }
 766   2            */
 767   2            break;
 768   2          case _SYSTEM_TIMER_EVENT_JUDGE_BATT_STATE:  
 769   2      
 770   2          #if (_DEBUG_MESSAGE_BATTERY_TEST)
                  #else
 772   2            BatteryVoltage=GetBatteryVoltage();
 773   2          #endif
 774   2          
 775   2            #if 1
 776   2          SET_BATTERY_CAPACITY(BatteryVoltage);
 777   2            
 778   2      //   if((GET_BATTERY_CAPACITY()<200)||(BatteryBTH>=935)) //no battery  <3.3V
 779   2      //     if(((GET_BATTERY_CAPACITY()<BATTERY_ACD_MIN)||(STAT1_Flag==1))&&(GET_AC_PLUG()==_TRUE)) //no battery
             -  <3.3V
 780   2      /*     if((GET_BATTERY_CAPACITY()<BATTERY_ACD_MIN)&&(GET_AC_PLUG()==_TRUE)) //no battery  <3.3V
 781   2              {
 782   2            SET_NO_BATTERY();
 783   2            SET_BATTERY_STATE(_BATT_STATUS_NO_BATT); 
 784   2              }
 785   2          else 
 786   2          */  
 787   2          {
 788   3            if(GET_NO_BATTERY()==_TRUE)
 789   3              {
 790   4              BattDetect1_COUNT=0;
C51 COMPILER V9.60.0.0   SYSTIMER                                                          12/22/2020 17:53:50 PAGE 14  

 791   4              BattDetect2_COUNT=0;
 792   4              BattDetect3_COUNT=0;
 793   4              BattDetect4_COUNT=0;
 794   4              BattDetect5_COUNT=0;
 795   4              BattDetectMin_COUNT=0;
 796   4              BattDetectHigh_COUNT=0;
 797   4              BattDetectHighStop_COUNT=0;
 798   4              BattDetectNoStartUp_COUNT=0;
 799   4              BATERY_STAT=_BATT_STATUS_CAPACITY_LEVEL4;
 800   4              }
 801   3              #if (_DEBUG_MESSAGE_Power_Supply_TEST==ON)
                      CLR_NO_BATTERY(); 
                      #endif
 804   3            if(BatteryVoltage<=BATTERY_CAPACITY_MIN) //<11.6V
 805   3            {
 806   4                  BattDetect1_COUNT=0;
 807   4                  BattDetect2_COUNT=0;
 808   4              BattDetect3_COUNT=0;
 809   4              BattDetect4_COUNT=0;
 810   4              BattDetect5_COUNT=0;              
 811   4              BattDetectMin_COUNT++;
 812   4              BattDetectHigh_COUNT=0;
 813   4              BattDetectHighStop_COUNT=0;
 814   4              BattDetectNoStartUp_COUNT=0;
 815   4            }
 816   3            else if((BatteryVoltage>BATTERY_CAPACITY_MIN)&&(BatteryVoltage<=BATTERY_CAPACITY_NO_STARTUP))
 817   3            {
 818   4            //_BATT_STATUS_CAPACITY_NO_STARTUP
 819   4                  BattDetect1_COUNT=0;
 820   4                  BattDetect2_COUNT=0;
 821   4              BattDetect3_COUNT=0;
 822   4              BattDetect4_COUNT=0;
 823   4              BattDetect5_COUNT=0;              
 824   4              BattDetectMin_COUNT=0;
 825   4              BattDetectHigh_COUNT=0;
 826   4              BattDetectHighStop_COUNT=0;               
 827   4              BattDetectNoStartUp_COUNT++;
 828   4            } 
 829   3            else if((BatteryVoltage>BATTERY_CAPACITY_NO_STARTUP)&&(BatteryVoltage<=BATTERY_CAPACITY_LEVEL0))
 830   3            {
 831   4            //_BATT_STATUS_CAPACITY_LEVEL0
 832   4                  BattDetect1_COUNT++;
 833   4                  BattDetect2_COUNT=0;
 834   4              BattDetect3_COUNT=0;
 835   4              BattDetect4_COUNT=0;
 836   4              BattDetect5_COUNT=0;              
 837   4              BattDetectMin_COUNT=0;
 838   4              BattDetectHigh_COUNT=0;
 839   4              BattDetectHighStop_COUNT=0;               
 840   4              BattDetectNoStartUp_COUNT=0;
 841   4            }     
 842   3            else if((BatteryVoltage>BATTERY_CAPACITY_LEVEL0)&&(BatteryVoltage<=BATTERY_CAPACITY_LEVEL1))
 843   3            {
 844   4              // _BATT_STATUS_CAPACITY_LEVEL1
 845   4                BattDetect1_COUNT=0;
 846   4                    BattDetect2_COUNT++;
 847   4              BattDetect3_COUNT=0;
 848   4              BattDetect4_COUNT=0;
 849   4              BattDetect5_COUNT=0;
 850   4              BattDetectMin_COUNT=0;
 851   4              BattDetectHigh_COUNT=0;
 852   4              BattDetectNoStartUp_COUNT=0;
C51 COMPILER V9.60.0.0   SYSTIMER                                                          12/22/2020 17:53:50 PAGE 15  

 853   4              
 854   4            }
 855   3            else if((BatteryVoltage>BATTERY_CAPACITY_LEVEL1)&&(BatteryVoltage<=BATTERY_CAPACITY_LEVEL2))
 856   3            {
 857   4            //_BATT_STATUS_CAPACITY_LEVEL2
 858   4                BattDetect1_COUNT=0;
 859   4                    BattDetect2_COUNT=0;
 860   4              BattDetect3_COUNT++;
 861   4              BattDetect4_COUNT=0;
 862   4              BattDetect5_COUNT=0;
 863   4              BattDetectMin_COUNT=0;
 864   4              BattDetectHigh_COUNT=0;
 865   4              BattDetectHighStop_COUNT=0;
 866   4              BattDetectNoStartUp_COUNT=0;
 867   4              
 868   4            }
 869   3            else if((BatteryVoltage>BATTERY_CAPACITY_LEVEL2)&&(BatteryVoltage<=BATTERY_CAPACITY_LEVEL3))
 870   3            {
 871   4              //_BATT_STATUS_CAPACITY_LEVEL3
 872   4                BattDetect1_COUNT=0;
 873   4                  BattDetect2_COUNT=0;
 874   4              BattDetect3_COUNT=0;
 875   4              BattDetect4_COUNT++;
 876   4              BattDetect5_COUNT=0;
 877   4              BattDetectMin_COUNT=0;
 878   4              BattDetectHigh_COUNT=0;
 879   4              BattDetectHighStop_COUNT=0;
 880   4              BattDetectNoStartUp_COUNT=0;
 881   4              
 882   4            }
 883   3            else if((BatteryVoltage>BATTERY_CAPACITY_LEVEL4)&&(BatteryVoltage<=BATTERY_CAPACITY_HIGH))
 884   3            {
 885   4              //_BATT_STATUS_CAPACITY_LEVEL4
 886   4                BattDetect1_COUNT=0;
 887   4              BattDetect2_COUNT=0;
 888   4              BattDetect3_COUNT=0;
 889   4              BattDetect4_COUNT=0;
 890   4              BattDetect5_COUNT++;
 891   4              BattDetectMin_COUNT=0;
 892   4              BattDetectHigh_COUNT=0;
 893   4              BattDetectHighStop_COUNT=0;
 894   4              BattDetectNoStartUp_COUNT=0;
 895   4              
 896   4          
 897   4            }
 898   3            else if((BatteryVoltage>BATTERY_CAPACITY_HIGH)&&(BatteryVoltage<=BATTERY_CAPACITY_HIGH_STOP)&&(PowerFla
             -g==ON))      
 899   3            {
 900   4              BattDetect1_COUNT=0;
 901   4              BattDetect2_COUNT=0;
 902   4              BattDetect3_COUNT=0;
 903   4              BattDetect4_COUNT=0;
 904   4              BattDetect5_COUNT=0;
 905   4              BattDetectMin_COUNT=0;
 906   4              BattDetectHigh_COUNT++; 
 907   4              BattDetectHighStop_COUNT=0;
 908   4              BattDetectNoStartUp_COUNT=0;
 909   4              
 910   4            }
 911   3            else if((BatteryVoltage>BATTERY_CAPACITY_HIGH)&&(BatteryVoltage<=(BATTERY_CAPACITY_HIGH_STOP+9))&&(Powe
             -rFlag==OFF))      
 912   3            {
C51 COMPILER V9.60.0.0   SYSTIMER                                                          12/22/2020 17:53:50 PAGE 16  

 913   4              BattDetect1_COUNT=0;
 914   4              BattDetect2_COUNT=0;
 915   4              BattDetect3_COUNT=0;
 916   4              BattDetect4_COUNT=0;
 917   4              BattDetect5_COUNT=0;
 918   4              BattDetectMin_COUNT=0;
 919   4              BattDetectHigh_COUNT++; 
 920   4              BattDetectHighStop_COUNT=0;
 921   4              BattDetectNoStartUp_COUNT=0;
 922   4              
 923   4            }
 924   3            else///>BATTERY_CAPACITY_HIGH_STOP
 925   3            {
 926   4              BattDetect1_COUNT=0;
 927   4              BattDetect2_COUNT=0;
 928   4              BattDetect3_COUNT=0;
 929   4              BattDetect4_COUNT=0;
 930   4              BattDetect5_COUNT=0;
 931   4              BattDetectMin_COUNT=0;
 932   4              BattDetectHigh_COUNT=0; 
 933   4              BattDetectHighStop_COUNT++;
 934   4              BattDetectNoStartUp_COUNT=0;
 935   4            }
 936   3      
 937   3            if(BatteryVoltage>=BATTERY_CAPACITY_STARTUP)
 938   3            BattDetectStartUp_COUNT++;
 939   3            else    
 940   3            BattDetectStartUp_COUNT=0;
 941   3            
 942   3            if(BattDetect1_COUNT==20)
 943   3            {
 944   4              BATERY_STAT=_BATT_STATUS_CAPACITY_LEVEL0;
 945   4              BattDetect1_COUNT=0;
 946   4            }
 947   3            if(BattDetect2_COUNT==20)
 948   3            {
 949   4              BATERY_STAT=_BATT_STATUS_CAPACITY_LEVEL1;
 950   4              BattDetect2_COUNT=0;
 951   4            }
 952   3            if(BattDetect3_COUNT==20)
 953   3            {
 954   4              BATERY_STAT=_BATT_STATUS_CAPACITY_LEVEL2;
 955   4              BattDetect3_COUNT=0;
 956   4            }
 957   3            if(BattDetect4_COUNT==20)
 958   3            {
 959   4              BATERY_STAT=_BATT_STATUS_CAPACITY_LEVEL3;
 960   4              BattDetect4_COUNT=0;
 961   4            }
 962   3            if(BattDetect5_COUNT==20)
 963   3            {
 964   4              BATERY_STAT=_BATT_STATUS_CAPACITY_LEVEL4;
 965   4              BattDetect5_COUNT=0;
 966   4            }
 967   3      
 968   3            if(BattDetectMin_COUNT==20)
 969   3            {
 970   4            BATERY_STAT=_BATT_STATUS_CAPACITY_MIN;
 971   4            BattDetectMin_COUNT=0;
 972   4            }
 973   3            
 974   3            if(BattDetectHigh_COUNT==20)
C51 COMPILER V9.60.0.0   SYSTIMER                                                          12/22/2020 17:53:50 PAGE 17  

 975   3            {
 976   4            BATERY_STAT=_BATT_STATUS_CAPACITY_MAX;
 977   4            BattDetectHigh_COUNT=0;
 978   4            }
 979   3      
 980   3            if(BattDetectNoStartUp_COUNT==20)
 981   3            {
 982   4            BATERY_STAT=_BATT_STATUS_CAPACITY_NO_STARTUP;
 983   4            BattDetectNoStartUp_COUNT=0;
 984   4            }
 985   3      
 986   3                if(BattDetectHigh_COUNT==20)
 987   3                {
 988   4                BATERY_STAT=_BATT_STATUS_CAPACITY_MAX;
 989   4                BattDetectHigh_COUNT=0;
 990   4                }
 991   3      
 992   3              if(BattDetectHighStop_COUNT==20)
 993   3              {
 994   4              BATERY_STAT=_BATT_STATUS_CAPACITY_MAX_STOP;
 995   4              BattDetectHighStop_COUNT=0;
 996   4              }
 997   3      
 998   3              if(BATERY_STAT_TEMP!=BATERY_STAT)
 999   3              {
1000   4              BATERY_STAT_TEMP=BATERY_STAT;
1001   4              SET_BATTERY_CHARGE_STATE(_BATT_STATUS_NONE);//reset battery state. 
1002   4              }
1003   3      
1004   3            if(BattDetectStartUp_COUNT==20)
1005   3            { 
1006   4              if(GET_BATTERY_CAPACITY_LOW_FLAG()==_TRUE)
1007   4                {
1008   5                #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
                         GraphicsPrint(RED,"(Normal Voltage Charge >12.5V)");
                        #endif
1011   5                CLR_BATTERY_CAPACITY_LOW_FLAG();
1012   5                SET_BATTERY_CHARGE_STATE(_BATT_STATUS_NONE);//reset battery state.  
1013   5      
1014   5                  if(ReadEEP(EEP_LowBattery_Flag))
1015   5                    WriteEEP(EEP_LowBattery_Flag,OFF);
1016   5                }
1017   4              
1018   4            BattDetectStartUp_COUNT=0;
1019   4            }
1020   3      
1021   3            
1022   3            SET_BATTERY_STATE(BATERY_STAT);
1023   3        }
1024   2          //#if (_DEBUG_MESSAGE_SysTimerEvent==ON)
1025   2          //GraphicsPrint(CYAN,">");
1026   2          //#endif
1027   2          
1028   2          MCUTimerActiveTimerEvent(SEC(0.3/*1*/), _SYSTEM_TIMER_EVENT_JUDGE_BATT_STATE);
1029   2            #else
                    SET_BATTERY_CAPACITY(BatteryVoltage);
                
                      
                     if((GET_BATTERY_CAPACITY()<200)||(BatteryBTH>=935)) //no battery  <3.3V
                      {
                    SET_NO_BATTERY();
                    SET_BATTERY_STATE(_BATT_STATUS_NO_BATT); 
C51 COMPILER V9.60.0.0   SYSTIMER                                                          12/22/2020 17:53:50 PAGE 18  

                      }
                  else 
                    {
                    CLR_NO_BATTERY();   
                    
                  if(GET_BATTERY_CAPACITY()<=BATTERY_CAPACITY_LEVEL0)//<12V
                       SET_BATTERY_STATE(_BATT_STATUS_CAPACITY_LEVEL0);        
                  else if((GET_BATTERY_CAPACITY()>BATTERY_CAPACITY_LEVEL0)&&(GET_BATTERY_CAPACITY()<=BATTERY_CAPACITY_LEVE
             -L1))//12V-13.5V
                    SET_BATTERY_STATE(_BATT_STATUS_CAPACITY_LEVEL1);      
                  else if((GET_BATTERY_CAPACITY()>BATTERY_CAPACITY_LEVEL1)&&(GET_BATTERY_CAPACITY()<=BATTERY_CAPACITY_LEVE
             -L2))//14.2V-13.5V
                    SET_BATTERY_STATE(_BATT_STATUS_CAPACITY_LEVEL2);
                  else if((GET_BATTERY_CAPACITY()>BATTERY_CAPACITY_LEVEL2)&&(GET_BATTERY_CAPACITY()<=BATTERY_CAPACITY_LEVE
             -L3))//15V-14.2V
                    SET_BATTERY_STATE(_BATT_STATUS_CAPACITY_LEVEL3);  
                  else    
                    SET_BATTERY_STATE(_BATT_STATUS_CAPACITY_LEVEL4);//>15V
                    }   
              
                  MCUTimerActiveTimerEvent(SEC(5), _SYSTEM_TIMER_EVENT_JUDGE_BATT_STATE);
              
                  #endif
1057   2      
1058   2          break;
1059   2      
1060   2          case _SYSTEM_TIMER_EVENT_JUDGE_PSW_STATE:
1061   2          #if (_DEBUG_MESSAGE_Scankey_CHECK==ON)
                  GraphicsPrint(CYAN,"\r\nPOWER key pressed");
                  #endif
1064   2      
1065   2            if(GET_DVR_EntrySleepMode()==_TRUE)
1066   2            {
1067   3              SET_TARGET_POWER_STATUS(_POWER_STATUS_NORMAL);
1068   3              //CLR_DVR_EntrySleepMode();
1069   3              //MCU_SendCmdToDVR(MCU_PROTOCOL_CMD_SLEEP_WAKE_UP);
1070   3              #if (_DEBUG_MESSAGE_Scankey_CHECK==ON)
                        GraphicsPrint(YELLOW,"(MCU_SLEEP_TO_NORMAL_MODE)");    
                      #endif        
1073   3      
1074   3            }
1075   2            #if 0 //for test
                    else if(PowerFlag==ON)    
                      {
                    MCUTimerActiveTimerEvent(SEC(0.1), _USER_TIMER_EVENT_OSD_DVR_SHUTDOWN);
                    PowerFlag=OFF;
                    WriteEEP(EEP_Powerflag,PowerFlag);
                      }
                    #else
1083   2            else if(PowerFlag==ON)    
1084   2            MCUTimerActiveTimerEvent(SEC(0.1), _USER_TIMER_EVENT_OSD_DVR_SHUTDOWN);
1085   2            #endif
1086   2            else
1087   2            {
1088   3                if(GET_DVR_PowerOFFDelay()==_FALSE)
1089   3                {
1090   4                  if((GET_BATTERY_CAPACITY_LOW_FLAG()==_FALSE)||(GET_AC_PLUG()==_TRUE))
1091   4                  {
1092   5                  PowerFlag=ON;
1093   5                  WriteEEP(EEP_Powerflag,PowerFlag);
1094   5                  }
1095   4                  else
C51 COMPILER V9.60.0.0   SYSTIMER                                                          12/22/2020 17:53:50 PAGE 19  

1096   4                    {
1097   5                    #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
                            GraphicsPrint(RED,"\r\n(Battery voltage low <12.5V...)");
                            #endif
1100   5                    MCUTimerActiveTimerEvent(SEC(0.01), _SYSTEM_TIMER_EVENT_BATT_LOW_RED_BLINK);
1101   5                    }
1102   4                  
1103   4                #if (_DEBUG_MESSAGE_Scankey_CHECK==ON)
                        if(PWR_START_flag==ON)
                            GraphicsPrint(YELLOW,"(DC12V to Power on)");    
                        #endif
1107   4                }
1108   3                else
1109   3                MCUTimerActiveTimerEvent(SEC(3), _SYSTEM_TIMER_EVENT_JUDGE_PSW_STATE);
1110   3                
1111   3            }
1112   2          
1113   2            break;
1114   2      case _SYSTEM_TIMER_EVENT_BATTERY_LOW_PWR_OFF:
1115   2           if(PowerFlag==ON)  
1116   2          MCUTimerActiveTimerEvent(SEC(0.1), _USER_TIMER_EVENT_OSD_DVR_SHUTDOWN);
1117   2        break;
1118   2          case _SYSTEM_TIMER_EVENT_JUDGE_BTH_STATE:
1119   2        
1120   2          #if (_DEBUG_MESSAGE_BATTERY_TEST)
                  #else
1122   2          BatteryBTH=GetBatteryBTH();
1123   2      
1124   2      //    if(GET_BATTERY_CHARGE_STATE()==_BATT_STATUS_NO_BATT)
1125   2      //      BatteryBTH=549;
1126   2          #endif
1127   2          
1128   2          //if((GET_BATTERY_CHARGE_STATE()==_BATT_STATUS_STOP_CHARGE)&&(GET_BTH_STATE()==_BATT_STATUS_TEMP_NORMAL)
             -)
1129   2          //SET_BTH_STATE(_BATT_STATUS_TEMP_NORMAL);
1130   2          //else
1131   2          //{
1132   2      
1133   2          #if 1
1134   2          if((BatteryBTH<=BTH_TEMP_HIGH)&&(BatteryBTH>BTH_TEMP_MIN)) //<11.6V
1135   2            {     
1136   3            TEMP_NORMAL_COUNT=0;
1137   3              TEMP_LOW_COUNT=0;
1138   3            TEMP_LOW_WARN_COUNT=0;
1139   3            TEMP_HIGH_COUNT++;
1140   3            TEMP_HIGH_WARN_COUNT=0;
1141   3            }
1142   2            else if((BatteryBTH>BTH_TEMP_HIGH)&&(BatteryBTH<=BTH_TEMP_HIGH_WARN))//50~55 warnning
1143   2            {
1144   3            TEMP_NORMAL_COUNT=0;
1145   3              TEMP_LOW_COUNT=0;
1146   3            TEMP_LOW_WARN_COUNT=0;
1147   3            TEMP_HIGH_COUNT=0;
1148   3            TEMP_HIGH_WARN_COUNT++;
1149   3            }   
1150   2            else if((BatteryBTH>BTH_TEMP_HIGH_WARN)&&(BatteryBTH<=BTH_TEMP_LOW_WARN))
1151   2            {
1152   3            TEMP_NORMAL_COUNT++;
1153   3            TEMP_LOW_COUNT=0;
1154   3            TEMP_LOW_WARN_COUNT=0;
1155   3            TEMP_HIGH_COUNT=0;
1156   3            TEMP_HIGH_WARN_COUNT=0;
C51 COMPILER V9.60.0.0   SYSTIMER                                                          12/22/2020 17:53:50 PAGE 20  

1157   3            }
1158   2            else if((BatteryBTH>BTH_TEMP_LOW_WARN)&&(BatteryBTH<=BTH_TEMP_LOW))  //0~-5 warnning
1159   2              {
1160   3              TEMP_NORMAL_COUNT=0;
1161   3              TEMP_LOW_COUNT=0;
1162   3              TEMP_LOW_WARN_COUNT++;
1163   3              TEMP_HIGH_COUNT=0;
1164   3              TEMP_HIGH_WARN_COUNT=0;
1165   3      
1166   3              }
1167   2            else if((BatteryBTH>BTH_TEMP_LOW)&&(BatteryBTH<=BATTERY_ACD_no_battery))  //-5~-10 warnning
1168   2              {
1169   3              TEMP_NORMAL_COUNT=0;
1170   3              TEMP_LOW_COUNT++;
1171   3              TEMP_LOW_WARN_COUNT=0;
1172   3              TEMP_HIGH_COUNT=0;
1173   3              TEMP_HIGH_WARN_COUNT=0;
1174   3              }
1175   2            else
1176   2              {
1177   3              #if (_DEBUG_MESSAGE_Power_Supply_TEST==ON)
                      #else
1179   3              SET_NO_BATTERY();
1180   3              SET_BATTERY_STATE(_BATT_STATUS_NO_BATT);
1181   3              #endif
1182   3              TEMP_STAT=_BATT_STATUS_TEMP_NORMAL; ///no DC12V input
1183   3            TEMP_NORMAL_COUNT=0;
1184   3              TEMP_LOW_COUNT=0;
1185   3            TEMP_LOW_WARN_COUNT=0;
1186   3            TEMP_HIGH_COUNT=0;
1187   3            TEMP_HIGH_WARN_COUNT=0;         
1188   3              }
1189   2      
1190   2          if(((TEMP_NORMAL_COUNT>3)||(TEMP_LOW_COUNT>3)||(TEMP_LOW_WARN_COUNT>3)||(TEMP_HIGH_COUNT>3)||(TEMP_HIGH_
             -WARN_COUNT>3)\
1191   2            )&&(PWR_START_flag==ON)&&(PowerFlag==OFF)&&(GET_NO_BATTERY()==_TRUE))
1192   2          PowerFlag=ON;
1193   2      
1194   2            
1195   2          if(TEMP_HIGH_COUNT==20)
1196   2          {
1197   3            TEMP_STAT=_BATT_STATUS_TEMP_HIGH;
1198   3            TEMP_HIGH_COUNT=0;
1199   3            CLR_BATTERY_HIGH_TMEP_WARN();
1200   3            CLR_BATTERY_LOW_TMEP_WARN();  
1201   3            CLR_NO_BATTERY();
1202   3          }
1203   2      
1204   2          if(TEMP_HIGH_WARN_COUNT==20)
1205   2          {
1206   3            TEMP_STAT=_BATT_STATUS_TEMP_HIGH_WARN;
1207   3            TEMP_HIGH_WARN_COUNT=0;
1208   3            SET_BATTERY_HIGH_TMEP_WARN();
1209   3            CLR_BATTERY_LOW_TMEP_WARN();
1210   3            CLR_NO_BATTERY();   
1211   3          }
1212   2      
1213   2          if(TEMP_NORMAL_COUNT==20)
1214   2          {
1215   3            TEMP_STAT=_BATT_STATUS_TEMP_NORMAL;
1216   3            TEMP_NORMAL_COUNT=0;
1217   3            CLR_BATTERY_LOW_TMEP_WARN();
C51 COMPILER V9.60.0.0   SYSTIMER                                                          12/22/2020 17:53:50 PAGE 21  

1218   3            CLR_BATTERY_HIGH_TMEP_WARN();
1219   3            CLR_NO_BATTERY();   
1220   3          }
1221   2      
1222   2          if(TEMP_LOW_WARN_COUNT==20)
1223   2          {
1224   3            TEMP_STAT=_BATT_STATUS_TEMP_LOW_WARN;
1225   3            TEMP_LOW_WARN_COUNT=0;
1226   3            SET_BATTERY_LOW_TMEP_WARN();
1227   3            CLR_BATTERY_HIGH_TMEP_WARN();
1228   3            CLR_NO_BATTERY();     
1229   3          }
1230   2      
1231   2          if(TEMP_LOW_COUNT==20)
1232   2          {
1233   3            TEMP_STAT=_BATT_STATUS_TEMP_LOW;
1234   3            TEMP_LOW_COUNT=0;
1235   3            CLR_BATTERY_LOW_TMEP_WARN();
1236   3            CLR_BATTERY_HIGH_TMEP_WARN(); 
1237   3            CLR_NO_BATTERY();   
1238   3          }
1239   2      /*
1240   2          if(GET_BATTERY_CHARGE_STATE()==_BATT_STATUS_NO_BATT)
1241   2            {
1242   2              TEMP_STAT=_BATT_STATUS_TEMP_NORMAL;
1243   2              CLR_BATTERY_LOW_TMEP_WARN();
1244   2              CLR_BATTERY_HIGH_TMEP_WARN();
1245   2      
1246   2            }
1247   2          */
1248   2          SET_BTH_STATE(TEMP_STAT);
1249   2      
1250   2      
1251   2            if((BatteryBTH<=CHARGE_TEMP_HIGH)||(BatteryBTH>CHARGE_TEMP_LOW))  
1252   2              {
1253   3              CHARGE_TEMP_ABNORMAL++;
1254   3              CHARGE_TEMP_NORMAL=0;
1255   3              }
1256   2              else
1257   2              {
1258   3              CHARGE_TEMP_ABNORMAL=0;
1259   3              CHARGE_TEMP_NORMAL++;
1260   3              //CLR_CHARGE_TMEP_ABNORMAL();
1261   3              }
1262   2              
1263   2              if(CHARGE_TEMP_ABNORMAL==20)
1264   2                {
1265   3                CHARGE_TEMP_ABNORMAL=0;
1266   3                  if((GET_AC_PLUG()==_TRUE)&&(GET_NO_BATTERY()==_FALSE))      
1267   3                  SET_CHARGE_TMEP_ABNORMAL();
1268   3                
1269   3                //  if(GET_BATTERY_CHARGE_STATE()==_BATT_STATUS_NO_BATT)  
1270   3                //    CLR_CHARGE_TMEP_ABNORMAL();                     
1271   3                }
1272   2              else  if(CHARGE_TEMP_NORMAL==20)
1273   2                {
1274   3                CHARGE_TEMP_NORMAL=0;
1275   3                CLR_CHARGE_TMEP_ABNORMAL();
1276   3                }
1277   2          #else
                      if((BatteryBTH<=BTH_TEMP_HIGH)&&(BatteryBTH>BTH_TEMP_MIN)) //>55
                      SET_BTH_STATE(_BATT_STATUS_TEMP_HIGH);          
C51 COMPILER V9.60.0.0   SYSTIMER                                                          12/22/2020 17:53:50 PAGE 22  

                    else if((BatteryBTH>BTH_TEMP_HIGH)&&(BatteryBTH<=BTH_TEMP_HIGH_WARN))//50~55 warnning
                      {
                      SET_BATTERY_HIGH_TMEP_WARN();   
                      CLR_BATTERY_LOW_TMEP_WARN();  
                      }
                    else if((BatteryBTH>BTH_TEMP_HIGH_WARN)&&(BatteryBTH<=BTH_TEMP_LOW_WARN))
                      {
                      SET_BTH_STATE(_BATT_STATUS_TEMP_NORMAL);        
                      CLR_BATTERY_LOW_TMEP_WARN();
                      CLR_BATTERY_HIGH_TMEP_WARN();
                      }
                    else if((BatteryBTH>BTH_TEMP_LOW_WARN)&&(BatteryBTH<=BTH_TEMP_LOW))  //0~-5 warnning
                      {
                      //SET_BATTERY_LOW_TMEP_WARN();
                      //CLR_BATTERY_HIGH_TMEP_WARN(); 
                      }
                    else if(BatteryBTH>BTH_TEMP_LOW)  //-5~-10 warnning
                      {
                      SET_BTH_STATE(_BATT_STATUS_TEMP_LOW);       
                      CLR_BATTERY_LOW_TMEP_WARN();
                      CLR_BATTERY_HIGH_TMEP_WARN();
                      }
                    else 
                      SET_BTH_STATE(_BATT_STATUS_TEMP_NORMAL);
                    
              
                    #endif  
1307   2          //}
1308   2                    
1309   2          MCUTimerActiveTimerEvent(SEC(0.3/*1*/), _SYSTEM_TIMER_EVENT_JUDGE_BTH_STATE);
1310   2          break;
1311   2      
1312   2          case _SYSTEM_TIMER_EVENT_JUDGE_WDT_ECHO:
1313   2      
1314   2      
1315   2            if(GET_DVR_WDTkickDisable()==_FALSE)
1316   2            {
1317   3            #if(_DEBUG_MESSAGE_WDT_KICK_CHECK == ON)    
                    GraphicsPrint(RED,"\r\n(WDT kick over 10 seconds, Try to reboot the DVR)"); 
                    #endif
1320   3            SET_DVR_Reboot();
1321   3            SET_DVR_RebootAndPower();
1322   3            MCUTimerActiveTimerEvent(SEC(1), _USER_TIMER_EVENT_OSD_DVR_REBOOT);
1323   3            }
1324   2          break;
1325   2      
1326   2          case _SYSTEM_TIMER_EVENT_JUDGE_AC_MODE:
1327   2          
1328   2              #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
                      GraphicsPrint(CYAN,"(AC)");
                      if(GET_STAT1()==ON)
                        GraphicsPrint(GREEN,"(S1=1)");
                      else
                        GraphicsPrint(GREEN,"(S1=0)");
                      
                      if(GET_STAT2()==ON)
                        GraphicsPrint(MAGENTA,"(S2=1)");
                      else
                        GraphicsPrint(MAGENTA,"(S2=0)");
                        
                      #endif
1341   2              
C51 COMPILER V9.60.0.0   SYSTIMER                                                          12/22/2020 17:53:50 PAGE 23  

1342   2                  if(Check_ADAP_IN()==_TRUE)
1343   2                  {
1344   3                    if(GET_AC_PLUG()!=_TRUE)
1345   3                    {
1346   4                      SET_AC_PLUG();
1347   4                      //SET_AC_MODE();  // turn on AC mode
1348   4                      CLR_AC_MODE();  // turn on AC mode
1349   4                      //MCUTimerDelayXms(100);//delay 50ms    
1350   4                      CLR_BAT_SYS();// turn off battery output              
1351   4                      //SET_PWM(_CHG_CURR,Low_Current);
1352   4      
1353   4                      STAT1_temp=GET_STAT1(); 
1354   4                      if(STAT1_Flag!=STAT1_temp)
1355   4                      STAT1_Flag=STAT1_temp;
1356   4                      
1357   4                      STAT2_temp=GET_STAT2(); 
1358   4                      if(STAT2_Flag!=STAT2_temp)
1359   4                      STAT2_Flag=STAT2_temp;
1360   4      
1361   4                    }         
1362   3                  
1363   3                  if(GET_NO_BATTERY()==_TRUE)
1364   3                    {
1365   4                  MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_NO_BATT);                
1366   4                    }
1367   3                  else
1368   3                    {
1369   4                    
1370   4                  if(GET_POWER_STATUS()==_POWER_STATUS_NORMAL)
1371   4                  {
1372   5                    
1373   5                    if((GET_BTH_STATE()==_BATT_STATUS_TEMP_NORMAL)&&(GET_BATTERY_CAPACITY_HIGH_FLAG()==_FALSE)&&(GET_BA
             -TTERY_ABNORMAL()==_FALSE)&&(GET_CHARGE_TMEP_ABNORMAL()==_FALSE)/*&&(GET_CHARGE_START_FLAG()==_TRUE)*/)
1374   5                      {
1375   6                        if(GET_BATTERY_CAPACITY_LOW_FLAG()==_FALSE)
1376   6                        MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_BATT_NORMAL_CHARGE);                   
1377   6                        else
1378   6                        MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_BATT_LOW_CHARGE);  
1379   6                      }
1380   5                    else if(GET_BATTERY_CHARGE_STATE()==_BATT_STATUS_NO_BATT)
1381   5                    MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_NO_BATT); 
1382   5                    else
1383   5                    MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_BATT_NO_CHARGE);   
1384   5                  }
1385   4                  else if(GET_POWER_STATUS()==_POWER_STATUS_SAVING)
1386   4                    {
1387   5                    
1388   5                    if((GET_BTH_STATE()==_BATT_STATUS_TEMP_NORMAL)&&(GET_BATTERY_CAPACITY_HIGH_FLAG()==_FALSE)&&(GET_BA
             -TTERY_ABNORMAL()==_FALSE)&&(GET_CHARGE_TMEP_ABNORMAL()==_FALSE)/*&&(GET_CHARGE_START_FLAG()==_TRUE)*/)
1389   5                      {
1390   6                      if(GET_BATTERY_CAPACITY_LOW_FLAG()==_FALSE)
1391   6                      MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_BATT_NORMAL_CHARGE);                   
1392   6                      else
1393   6                      MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_BATT_LOW_CHARGE);
1394   6                      }
1395   5                      else if(GET_BATTERY_CHARGE_STATE()==_BATT_STATUS_NO_BATT)
1396   5                      MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_NO_BATT); 
1397   5                      else
1398   5                      MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_BATT_NO_CHARGE); 
1399   5                    }
1400   4                  else if(GET_POWER_STATUS()==_POWER_STATUS_OFF)
1401   4                    {
C51 COMPILER V9.60.0.0   SYSTIMER                                                          12/22/2020 17:53:50 PAGE 24  

1402   5                      
1403   5                      if((GET_BTH_STATE()==_BATT_STATUS_TEMP_NORMAL)&&(GET_BATTERY_CAPACITY_HIGH_FLAG()==_FALSE)&&(GET_B
             -ATTERY_ABNORMAL()==_FALSE)&&(GET_CHARGE_TMEP_ABNORMAL()==_FALSE)/*&&(GET_CHARGE_START_FLAG()==_TRUE)*/)
1404   5                        {
1405   6                        if(GET_BATTERY_CAPACITY_LOW_FLAG()==_FALSE)
1406   6                          MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_BATT_HIGH_CHARGE); 
1407   6                        else
1408   6                          MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_BATT_LOW_CHARGE);  
1409   6                        }
1410   5                      else if(GET_BATTERY_CHARGE_STATE()==_BATT_STATUS_NO_BATT)
1411   5                      MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_NO_BATT); 
1412   5                      else
1413   5                      MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_BATT_NO_CHARGE); 
1414   5                    }
1415   4                          
1416   4                  
1417   4                    }
1418   3                
1419   3                  MCUTimerActiveTimerEvent(SEC(5), _SYSTEM_TIMER_EVENT_JUDGE_AC_MODE);   //repeat on AC mode
1420   3      
1421   3      
1422   3                  }
1423   2                else
1424   2                  {
1425   3                  CLR_AC_PLUG();
1426   3                  CLR_AC_MODE();  // turn off AC mode
1427   3                  SET_AC_PLUG_OUT();
1428   3                  CLR_BATTERY_CAPACITY_HIGH_FLAG(); 
1429   3                  if((PWR_START_flag==ON)&&(PowerFlag==ON))
1430   3                  MCU_SendCmdToDVR(MCU_PROTOCOL_CMD_SYSTEM_SHUTDOWN);///SET_AC_PLUG_OUT             
1431   3                  MCUTimerActiveTimerEvent(SEC(0.5), _SYSTEM_TIMER_EVENT_BATT_NO_CHARGE);  //change battery mode          
1432   3                  MCUTimerActiveTimerEvent(SEC(0.5), _SYSTEM_TIMER_EVENT_JUDGE_BATT_MODE);  //going to battery mode
1433   3                  }
1434   2      
1435   2                CLR_AC_MODE();  
1436   2                    CLR_BAT_SYS();
1437   2          break;
1438   2                      case _SYSTEM_TIMER_EVENT_CHECK_CHARGE_STATE:
1439   2      
1440   2                    STAT1_temp=GET_STAT1();
1441   2                    STAT2_temp=GET_STAT2();
1442   2                  
1443   2                    #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
                            GraphicsPrint(YELLOW,"(STAT1_temp=%02x)",(WORD)STAT1_temp);
                            #endif  
1446   2                    #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
                            GraphicsPrint(GREEN,"(STAT2_temp=%02x)",(WORD)STAT2_temp);
                            #endif  
1449   2                    
1450   2                    if((STAT1_Flag!=STAT1_temp)&&(GET_NO_BATTERY()==_FALSE))
1451   2                      {
1452   3                      STAT1_Flag=STAT1_temp;
1453   3                      SET_BATTERY_CHARGE_STATE(_BATT_STATUS_NONE);//reset battery state.              
1454   3                      }
1455   2                    
1456   2                      if((STAT2_Flag!=STAT2_temp)&&(GET_NO_BATTERY()==_FALSE))
1457   2                      {
1458   3                      STAT2_Flag=STAT2_temp;
1459   3                      SET_BATTERY_CHARGE_STATE(_BATT_STATUS_NONE);//reset battery state.              
1460   3                      }
1461   2            
1462   2                #if 1
C51 COMPILER V9.60.0.0   SYSTIMER                                                          12/22/2020 17:53:50 PAGE 25  

1463   2                    if(GET_BATTERY_ABNORMAL()==_FALSE)
1464   2                    { 
1465   3                        if(GET_BATTERY_CAPACITY()>=BATTERY_ACD_MAX)//>17    
1466   3                        {
1467   4                        #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
                                GraphicsPrint(RED,"( HigH Voltage >17V shut down)");
                                #endif
1470   4                        SET_BATTERY_ABNORMAL();
1471   4                        MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_JUDGE_PSW_STATE);            
1472   4                        }
1473   3                  
1474   3                    }
1475   2      
1476   2                        switch(GET_BATTERY_STATE())
1477   2                        {
1478   3      
1479   3                      case _BATT_STATUS_CAPACITY_MAX_STOP:
1480   3                        
1481   3                          if(GET_BATTERY_CAPACITY_HIGH_FLAG()==_FALSE)
1482   3                          {
1483   4                          #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
                                  GraphicsPrint(RED,"(HIGH Voltage >16.4V stop charge)");
                                  #endif  
1486   4                          SET_BATTERY_CAPACITY_HIGH_FLAG();   
1487   4                          }
1488   3                          
1489   3                         if(GET_BATTERY_CAPACITY_LOW_FLAG()==_TRUE)
1490   3                         {     
1491   4                          #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
                                   GraphicsPrint(RED,"(2.Normal Voltage Charge >12V)");
                                  #endif
1494   4                         CLR_BATTERY_CAPACITY_LOW_FLAG();  
1495   4                         SET_BATTERY_CHARGE_STATE(_BATT_STATUS_NONE);//reset battery state.  
1496   4                          if(ReadEEP(EEP_LowBattery_Flag))
1497   4                            WriteEEP(EEP_LowBattery_Flag,OFF);
1498   4                         }
1499   3                         CLR_CHARGE_START_FLAG();
1500   3                        break;
1501   3                      case _BATT_STATUS_CAPACITY_MIN:
1502   3                      case _BATT_STATUS_CAPACITY_NO_STARTUP:
1503   3                          if((GET_BATTERY_CAPACITY_LOW_FLAG()==_FALSE)&&(GET_DVR_SystemReadyNotic()==_FALSE)&&(GET_AC_PLUG
             -()==_FALSE))
1504   3                          {
1505   4                          SET_BATTERY_CAPACITY_LOW_FLAG();  
1506   4                          
1507   4                          if(ReadEEP(EEP_LowBattery_Flag)==OFF)
1508   4                          WriteEEP(EEP_LowBattery_Flag,ON);
1509   4                          
1510   4                          #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
                                  GraphicsPrint(RED,"( Low Voltage <11.8V or < 11.6V shut down)");
                                  #endif                                      
1513   4                          MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_JUDGE_PSW_STATE);  
1514   4                          }
1515   3                          else  if((GET_BATTERY_STATE()==_BATT_STATUS_CAPACITY_MIN)&&(PowerFlag==ON)&&(GET_AC_PLUG()==_FALS
             -E))
1516   3                          {
1517   4                          PowerFlag=OFF;
1518   4                          WriteEEP(EEP_Powerflag,PowerFlag);
1519   4                          }
1520   3                          CLR_BATTERY_CAPACITY_HIGH_FLAG(); 
1521   3                          SET_CHARGE_START_FLAG();
1522   3                        break;
C51 COMPILER V9.60.0.0   SYSTIMER                                                          12/22/2020 17:53:50 PAGE 26  

1523   3      
1524   3                       case _BATT_STATUS_CAPACITY_LEVEL0:
1525   3                         CLR_BATTERY_CAPACITY_HIGH_FLAG();   
1526   3                        //  CLR_BATTERY_CAPACITY_LOW_FLAG();  
1527   3                        break;
1528   3                       case _BATT_STATUS_CAPACITY_LEVEL1:                 
1529   3                       case _BATT_STATUS_CAPACITY_LEVEL2:
1530   3                       case _BATT_STATUS_CAPACITY_LEVEL3:
1531   3                       case _BATT_STATUS_CAPACITY_LEVEL4:
1532   3                       case _BATT_STATUS_CAPACITY_MAX:
1533   3      
1534   3                         SET_CHARGE_START_FLAG();
1535   3                         /*
1536   3                         if(GET_BATTERY_CAPACITY_LOW_FLAG()==_TRUE)
1537   3                         {     
1538   3                          #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
1539   3                           GraphicsPrint(RED,"(Normal Voltage Charge >12V)");
1540   3                          #endif
1541   3                         CLR_BATTERY_CAPACITY_LOW_FLAG();  
1542   3                         SET_BATTERY_CHARGE_STATE(_BATT_STATUS_NONE);//reset battery state.  
1543   3                         }  
1544   3                         */
1545   3                         CLR_BATTERY_CAPACITY_HIGH_FLAG();   
1546   3                          break;
1547   3                      //case _BATT_STATUS_CAPACITY_MAX:
1548   3                      //  CLR_CHARGE_START_FLAG();
1549   3                        
1550   3                        //break;
1551   3                        }
1552   2            #else
                            if(GET_BATTERY_CAPACITY_LOW_FLAG()==_FALSE)
                            { 
                              if(GET_BATTERY_STATE()==_BATT_STATUS_CAPACITY_MIN)//<11.6V    
                              {
                              SET_BATTERY_CAPACITY_LOW_FLAG();                                      
                              #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
                              GraphicsPrint(RED,"( Low Voltage <11.6V shut down)");
                              #endif                                      
                              MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_JUDGE_PSW_STATE);            
                              }             
                              
                            }
              
                
                            if(GET_BATTERY_ABNORMAL()==_FALSE)
                            { 
                                if(GET_BATTERY_CAPACITY()>=BATTERY_ACD_MAX)//>17    
                                {
                                #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
                                GraphicsPrint(RED,"( HigH Voltage >17V shut down)");
                                #endif
                                SET_BATTERY_ABNORMAL();
                                MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_JUDGE_PSW_STATE);            
                                }
                          
                            }
                      //}
              
                              if(GET_BATTERY_CAPACITY_LOW_FLAG()==_TRUE)
                              {   
                                if(GET_BATTERY_STATE()!=_BATT_STATUS_CAPACITY_MIN)//<11.6V    
                                {
C51 COMPILER V9.60.0.0   SYSTIMER                                                          12/22/2020 17:53:50 PAGE 27  

                                #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
                                GraphicsPrint(RED,"(Normal Voltage Charge >12V)");
                                #endif
                                CLR_BATTERY_CAPACITY_LOW_FLAG();  
                                SET_BATTERY_CHARGE_STATE(_BATT_STATUS_NONE);//reset battery state.  
                                }         
                              }
                          //  if(((GET_BATTERY_CAPACITY()>675)||(GET_BATTERY_CAPACITY()<1023))&&(GET_BATTERY_ABNORMAL()==_TRUE)
             -)    
                            //      CLR_BATTERY_ABNORMAL();
              
                            if(GET_BATTERY_STATE()==_BATT_STATUS_CAPACITY_MAX)//>16.4V
                            {
                                  if(GET_BATTERY_CAPACITY_HIGH_FLAG()==_FALSE)
                                  {
                                  #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
                                  GraphicsPrint(RED,"(HIGH Voltage >15.5V stop charge)");
                                  #endif  
                                  SET_BATTERY_CAPACITY_HIGH_FLAG();   
                                  //SET_BATTERY_CHARGE_STATE(_BATT_STATUS_NONE);//reset battery state.
                                  }
                                  
                            }
                            else
                              CLR_BATTERY_CAPACITY_HIGH_FLAG(); 
                            
                    #endif        
1611   2                MCUTimerActiveTimerEvent(SEC(10-5), _SYSTEM_TIMER_EVENT_CHECK_CHARGE_STATE);  //check charge
1612   2                break;
1613   2          case     _SYSTEM_TIMER_EVENT_JUDGE_BATT_MODE:
1614   2            #if(_DEBUG_MESSAGE_SysTimerEvent==ON)
                    GraphicsPrint(CYAN,"(BATT)");
                      if(GET_STAT1()==ON)
                        GraphicsPrint(MAGENTA,"(S1=1)");
                      else
                        GraphicsPrint(GREEN,"(S1=0)");
                      
                      if(GET_STAT2()==ON)
                        GraphicsPrint(MAGENTA,"(S2=1)");
                      else
                        GraphicsPrint(GREEN,"(S2=0)");
                    #endif
1626   2          
1627   2            if(Check_ADAP_IN()==_TRUE)
1628   2              {
1629   3      
1630   3                if((PWR_START_flag==ON)&&(PowerFlag==OFF))
1631   3                {
1632   4                MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_JUDGE_PSW_STATE);
1633   4                }
1634   3      
1635   3              SET_BATTERY_CHARGE_STATE(_BATT_STATUS_NONE);//reset battery state.
1636   3              MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_JUDGE_AC_MODE);  
1637   3              }
1638   2            else 
1639   2              {
1640   3              if(GET_BAT_SYS()!=ON)
1641   3                {
1642   4                //SET_BAT_SYS();   // turn on  battery mode
1643   4                CLR_BAT_SYS();   // turn on  battery mode
1644   4                //MCUTimerDelayXms(100);//delay 50ms          
1645   4                CLR_AC_MODE();  // turn off AC mode
C51 COMPILER V9.60.0.0   SYSTIMER                                                          12/22/2020 17:53:50 PAGE 28  

1646   4                }
1647   3      
1648   3                //if((GET_BATTERY_STATE()==_BATT_STATUS_CAPACITY_LEVEL0)&&(PowerFlag==ON))
1649   3                //MCUTimerActiveTimerEvent(SEC(0.1), _USER_TIMER_EVENT_OSD_DVR_SHUTDOWN);
1650   3      
1651   3                MCUTimerActiveTimerEvent(SEC(0.1), _SYSTEM_TIMER_EVENT_BATT_NO_CHARGE);       
1652   3      
1653   3      
1654   3              MCUTimerActiveTimerEvent(SEC(5), _SYSTEM_TIMER_EVENT_JUDGE_BATT_MODE);
1655   3              }
1656   2      
1657   2                CLR_AC_MODE();  
1658   2                    CLR_BAT_SYS();
1659   2            break;
1660   2      
1661   2            case _SYSTEM_TIMER_EVENT_BATT_LOW_CHARGE: 
1662   2              if(GET_BATTERY_CHARGE_STATE()!=_BATT_STATUS_LOW_CHARGE)
1663   2              UserInterfaceBatteryChargeMode(_BATT_STATUS_LOW_CHARGE);
1664   2          break;
1665   2      
1666   2        case  _SYSTEM_TIMER_EVENT_BATT_HIGH_CHARGE:   
1667   2              if(GET_BATTERY_CHARGE_STATE()!=_BATT_STATUS_HIGH_CHARGE)
1668   2              UserInterfaceBatteryChargeMode(_BATT_STATUS_HIGH_CHARGE);         
1669   2              break;
1670   2        case  _SYSTEM_TIMER_EVENT_BATT_NORMAL_CHARGE:   
1671   2            if(GET_BATTERY_CHARGE_STATE()!=_BATT_STATUS_NORMAL_CHARGE)
1672   2              UserInterfaceBatteryChargeMode(_BATT_STATUS_NORMAL_CHARGE);             
1673   2            break;
1674   2      
1675   2        case  _SYSTEM_TIMER_EVENT_BATT_NO_CHARGE:   
1676   2              if(GET_BATTERY_CHARGE_STATE()!=_BATT_STATUS_STOP_CHARGE)
1677   2              UserInterfaceBatteryChargeMode(_BATT_STATUS_STOP_CHARGE);         
1678   2            break;
1679   2      
1680   2      
1681   2        case  _SYSTEM_TIMER_EVENT_NO_BATT:  
1682   2              if(GET_BATTERY_CHARGE_STATE()!=_BATT_STATUS_NO_BATT)
1683   2              UserInterfaceBatteryChargeMode(_BATT_STATUS_NO_BATT);         
1684   2              break;
1685   2            
1686   2      
1687   2              case _SYSTEM_TIMER_EVENT_SHOW_WORKING_TIMER:
1688   2        
1689   2            second+=10;
1690   2          
1691   2            if(second==60)
1692   2            {
1693   3              second=0;
1694   3              minute++;
1695   3            }
1696   2        
1697   2            if(minute==60)
1698   2            {
1699   3              minute=0;
1700   3              hour++;
1701   3            }
1702   2        
1703   2            if(hour==24)
1704   2            {
1705   3              hour=0;
1706   3              day++;
1707   3            } 
C51 COMPILER V9.60.0.0   SYSTIMER                                                          12/22/2020 17:53:50 PAGE 29  

1708   2      
1709   2          ShowWorkingTimer();
1710   2      
1711   2          MCUTimerActiveTimerEvent(SEC(10), _SYSTEM_TIMER_EVENT_SHOW_WORKING_TIMER);
1712   2             break;
1713   2      #if (_POWER_DOWN_ENABLE==ON)
1714   2          case _SYSTEM_TIMER_POWER_DOWN_MODE:
1715   2          //SET_MCU_POWER_DOWN_MODE();
1716   2          Power_down_mode=2;
1717   2              
1718   2          break;
1719   2      #endif
1720   2         default:
1721   2                  break;
1722   2       }
1723   1      }
1724          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4949    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     92      19
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
